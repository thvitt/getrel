Automatic downloader for binary releases.

## Introduction

getrel allows to download and install tools that are not packaged for your distribution and will be installed for a specific user. It is driven by a simple configuration file im TOML format that can be managed within your dotfiles, and it offers a few commands to noninteractively download, install and update the configured tools.

Additionally, it offers an interactive wizard that helps to configure a new tool.

Currently, only GitHub releases are supported. Support for arbitrary websites is planned. Other sources may be included as required.

## Installation

1. Install getrel either by downloading the binary from the releases page or using pipx by `pipx install getrel`.

## Tasks

### Interactively install a file from github

2. Use `getrel add <URL>` to interactively configure and install the tool at URL. E.g., try `getrel add https://github.com/sharkdp/fd` to install [fd](https://github.com/sharkdp/fd).

Run `getrel install --update` to update all configured tools to the latest version according to the configuration. Use `getrel uninstall <tool> to uninstall a tool. Run `getrel --help` for a list of commands, and `getrel <command> --help` for all options to the given command.

## Concepts and configuration

getrel is driven by a single projects list, which is a TOML file at `$XDG_CONFIG_HOME/getrel/projects.toml` (usually this will be `~/.config/getrel/projects.toml`). Here is an example configuration excerpt. All but the last line have been more or less automatically generated by the wizard at `getrel add sharkdp/fd`.

```toml
[fd]
kind = "github"
url = "https://github.com/sharkdp/fd"
release = "latest"

[fd.assets]
"fd-*-x86_64-unknown-linux-musl.tar.gz" = "unpack"

[fd.install]
"fd-*-x86_64-unknown-linux-musl/fd" = "bin"
"*/autocomplete/_fd" = { link = "~/.zsh/functions/" }
```

* `fd` is the **name** that identifies the project within getrel. The name can be arbitrarily chosen.
* `kind` determines by which API the project is downloaded. Currently, the only supported value is `"github"` for GitHub releases.
* For GitHub releases:

    * `url` is the URL to the GitHub project's root page.
    * `release` specifies which release is to be installed. This field can take one of the following forms:

	* The keyword `"latest"` to always install the latest stable release.
	* `"pre"` to always install the latest version, even if it is marked as prerelease.
	* A version string, or a shell glob pattern. This will select the latest version that matches the given pattern or string. This will be matched against the tag name. E.g., `"v8.*"` will select the newest version starting with `v8.`.
* `assets` lists the files that should be downloaded for the selected release, and what to do with them after download (see the Installation section below).
* `install` contains a table of installation instructions, see below
* `postinstall` can contain an installation script, see the next section.


### Download and Installation

By default installation means that there is a _project directory_ at `~/.local/share/getrel/<project>` for each project. Assets will be downloaded to this directory, and files needed somewhere else will be symlinked there. The directory also features a subdirectory `.getrel` which contains status and cache data managed by getrel. Getrel will track files it created itself and try to remove them on uninstall.

Download and installation for each project are controlled by two subtables, `assets` and `install`. Additionally, there may be string keys `postinstall` and `uninstall` for arbitrary user scripts to run.

The **assets** table maps shell glob patterns of assets to download to installation specifications. Each key in the table is matched against the assets of the current release. Each asset that matches will be downloaded to the project directory, then the associated installation specification is run on it.

Afterwards, the **install** table is evaluated. Each key in the table is matched against the files created by the installation in the project directory. For each match, the associated installation specification is run. 

Finally, if a `postinstall` key is present, it will be interpreted as shell script or command and run in the project directory.

### Installation Specifications

The installation instructions for both assets and other files follow either the form `source = "action"` or `source = { action = "argument" }`. `source` is the pattern matching the asset or file, `action` is one of the keywords in the list below, and `argument` is an optional action-specific argument. The following actions are available:

* `unpack` unpacks the source if it is a tar or zip archive. An optional argument may specify a target directory, if none given, the source's parent directory is used (which is usually the project directory). We try to ignore 'unsafe' archive members (mainly absolute paths).
* `link` creates a symbolic link at the path given as an argument that points to the source file.
* `bin` makes the source file executable and then creates a symbolic link to it at the given argument. If no argument is given, it is assumed to be the stem (filename without extension or directory) of the source file. If an argument is given, but is only a plain word (ie. does not contain a `/`), the target is assumed to be `~/.local/bin/<argument>`. I.e., all the following lines are equivalent:

    ```toml
    "fd-*-x86_64-unknown-linux-musl/fd" = "bin"
    "fd-*-x86_64-unknown-linux-musl/fd" = { bin = "fd" }
    "fd-*-x86_64-unknown-linux-musl/fd" = { bin = "~/.local/bin/fd" }
    ```
* `delete` deletes the source file.
* `record` does nothing, but simply records the source file as an installed file (that will be removed on uninstallation).

For all actions, the source will be matched using shell glob patterns and the _argument_ will undergo user and variable expansion. Files created using the built-in actions will be recorded and checked for additional actions during installation process, and removed on uninstallation.

### Installation scripts and commands

For each project, you can add a single optional `postinstall` and a single optional `uninstall` key. The values must be strings. If a value begins with `#!`, the string is written to a temporary file, which will then be made executable and executed. Otherwise, the value will be run as a single shell command. Either way, the script / command will be executed within the project directory and have access to the additional environment variable PROJECT and PROJECT_DIR with the name and directory of the project. The scripts are not intended for being interactive, their output is captured.

The `postinstall` script, if given, is run after each of the other install actions have been run. If it creates any files, it should write the file paths to stdout, one per line, and they will be added to the list of installed files (which will later be uninstalled). The `uninstall` script is run on _uninstall_, before any of the installed files will be deleted.
